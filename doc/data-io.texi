@c PSPP - a program for statistical analysis.
@c Copyright (C) 2017, 2020 Free Software Foundation, Inc.
@c Permission is granted to copy, distribute and/or modify this document
@c under the terms of the GNU Free Documentation License, Version 1.3
@c or any later version published by the Free Software Foundation;
@c with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
@c A copy of the license is included in the section entitled "GNU
@c Free Documentation License".
@c
@c (modify-syntax-entry ?_ "w")
@c (modify-syntax-entry ?' "'")
@c (modify-syntax-entry ?@ "'")


@node Data Input and Output
@chapter Data Input and Output
@cindex input
@cindex output
@cindex data
@cindex cases
@cindex observations

Data are the focus of the @pspp{} language.
Each datum  belongs to a @dfn{case} (also called an @dfn{observation}).
Each case represents an individual or ``experimental unit''.
For example, in the results of a survey, the names of the respondents,
their sex, age, etc.@: and their responses are all data and the data
pertaining to single respondent is a case.
This chapter examines
the @pspp{} commands for defining variables and reading and writing data.
There are alternative commands to  read data from predefined sources
such as system files or databases (@xref{GET, GET DATA}.)

@quotation Note
These commands tell @pspp{} how to read data, but the data will not
actually be read until a procedure is executed.
@end quotation

@menu
* BEGIN DATA::                  Embed data within a syntax file.
* CLOSE FILE HANDLE::           Close a file handle.
* DATAFILE ATTRIBUTE::          Set custom attributes on data files.
* DATASET::                     Manage multiple datasets.
* DATA LIST::                   Fundamental data reading command.
* END CASE::                    Output the current case.
* END FILE::                    Terminate the current input program.
* FILE HANDLE::                 Support for special file formats.
* INPUT PROGRAM::               Support for complex input programs.
* LIST::                        List cases in the active dataset.
* NEW FILE::                    Clear the active dataset.
* PRINT::                       Display values in print formats.
* PRINT EJECT::                 Eject the current page then print.
* PRINT SPACE::                 Print blank lines.
* REREAD::                      Take another look at the previous input line.
* WRITE::                       Display values in write formats.
@end menu

@node BEGIN DATA
@section BEGIN DATA
@vindex BEGIN DATA
@vindex END DATA
@cindex Embedding data in syntax files
@cindex Data, embedding in syntax files

@display
BEGIN DATA.
@dots{}
END DATA.
@end display

@cmd{BEGIN DATA} and @cmd{END DATA} can be used to embed raw ASCII
data in a @pspp{} syntax file.  @cmd{DATA LIST} or another input
procedure must be used before @cmd{BEGIN DATA} (@pxref{DATA LIST}).
@cmd{BEGIN DATA} and @cmd{END DATA} must be used together.  @cmd{END
DATA} must appear by itself on a single line, with no leading
white space and exactly one space between the words @code{END} and
@code{DATA}, like this:

@example
END DATA.
@end example

@node CLOSE FILE HANDLE
@section CLOSE FILE HANDLE

@display
CLOSE FILE HANDLE @var{handle_name}.
@end display

@cmd{CLOSE FILE HANDLE} disassociates the name of a file handle with a
given file.  The only specification is the name of the handle to close.
Afterward
@cmd{FILE HANDLE}.

The file named INLINE, which represents data entered between @cmd{BEGIN
DATA} and @cmd{END DATA}, cannot be closed.  Attempts to close it with
@cmd{CLOSE FILE HANDLE} have no effect.

@cmd{CLOSE FILE HANDLE} is a @pspp{} extension.

@node DATAFILE ATTRIBUTE
@section DATAFILE ATTRIBUTE
@vindex DATAFILE ATTRIBUTE

@display
DATAFILE ATTRIBUTE
         ATTRIBUTE=@var{name}('@var{value}') [@var{name}('@var{value}')]@dots{}
         ATTRIBUTE=@var{name}@b{[}@var{index}@b{]}('@var{value}') [@var{name}@b{[}@var{index}@b{]}('@var{value}')]@dots{}
         DELETE=@var{name} [@var{name}]@dots{}
         DELETE=@var{name}@b{[}@var{index}@b{]} [@var{name}@b{[}@var{index}@b{]}]@dots{}
@end display

@cmd{DATAFILE ATTRIBUTE} adds, modifies, or removes user-defined
attributes associated with the active dataset.  Custom data file
attributes are not interpreted by @pspp{}, but they are saved as part of
system files and may be used by other software that reads them.

Use the @subcmd{ATTRIBUTE} subcommand to add or modify a custom data file
attribute.  Specify the name of the attribute as an identifier
(@pxref{Tokens}), followed by the desired value, in parentheses, as a
quoted string.  Attribute names that begin with @code{$} are reserved
for @pspp{}'s internal use, and attribute names that begin with @code{@@}
or @code{$@@} are not displayed by most @pspp{} commands that display
other attributes.  Other attribute names are not treated specially.

Attributes may also be organized into arrays.  To assign to an array
element, add an integer array index enclosed in square brackets
(@code{[} and @code{]}) between the attribute name and value.  Array
indexes start at 1, not 0.  An attribute array that has a single
element (number 1) is not distinguished from a non-array attribute.

Use the @subcmd{DELETE} subcommand to delete an attribute.  Specify an
attribute name by itself to delete an entire attribute, including all
array elements for attribute arrays.  Specify an attribute name
followed by an array index in square brackets to delete a single
element of an attribute array.  In the latter case, all the array
elements numbered higher than the deleted element are shifted down,
filling the vacated position.

To associate custom attributes with particular variables, instead of
with the entire active dataset, use @cmd{VARIABLE ATTRIBUTE}
(@pxref{VARIABLE ATTRIBUTE}) instead.

@cmd{DATAFILE ATTRIBUTE} takes effect immediately.  It is not affected
by conditional and looping structures such as @cmd{DO IF} or
@cmd{LOOP}.

@node DATASET
@section DATASET commands
@vindex DATASET

@display
DATASET NAME @var{name} [WINDOW=@{ASIS,FRONT@}].
DATASET ACTIVATE @var{name} [WINDOW=@{ASIS,FRONT@}].
DATASET COPY @var{name} [WINDOW=@{MINIMIZED,HIDDEN,FRONT@}].
DATASET DECLARE @var{name} [WINDOW=@{MINIMIZED,HIDDEN,FRONT@}].
DATASET CLOSE @{@var{name},*,ALL@}.
DATASET DISPLAY.
@end display

The @cmd{DATASET} commands simplify use of multiple datasets within a
@pspp{} session.  They allow datasets to be created and destroyed.  At
any given time, most @pspp{} commands work with a single dataset, called
the active dataset.

@vindex DATASET NAME
The DATASET NAME command gives the active dataset the specified name, or
if it already had a name, it renames it.  If another dataset already
had the given name, that dataset is deleted.

@vindex DATASET ACTIVATE
The DATASET ACTIVATE command selects the named dataset, which must
already exist, as the active dataset.  Before switching the active
dataset, any pending transformations are executed, as if @cmd{EXECUTE}
had been specified.  If the active dataset is unnamed before
switching, then it is deleted and becomes unavailable after switching.

@vindex DATASET COPY
The DATASET COPY command creates a new dataset with the specified
name, whose contents are a copy of the active dataset.  Any pending
transformations are executed, as if @cmd{EXECUTE} had been specified,
before making the copy.  If a dataset with the given name already
exists, it is replaced.  If the name is the name of the active
dataset, then the active dataset becomes unnamed.

@vindex DATASET DECLARE
The DATASET DECLARE command creates a new dataset that is initially
``empty,'' that is, it has no dictionary or data.  If a dataset with
the given name already exists, this has no effect.  The new dataset
can be used with commands that support output to a dataset,
@i{e.g.} AGGREGATE (@pxref{AGGREGATE}).

@vindex DATASET CLOSE
The DATASET CLOSE command deletes a dataset.  If the active dataset is
specified by name, or if @samp{*} is specified, then the active
dataset becomes unnamed.  If a different dataset is specified by name,
then it is deleted and becomes unavailable.  Specifying ALL deletes
all datasets except for the active dataset, which becomes unnamed.

@vindex DATASET DISPLAY
The DATASET DISPLAY command lists all the currently defined datasets.

Many DATASET commands accept an optional @subcmd{WINDOW} subcommand.  In the
@pspp{}IRE GUI, the value given for this subcommand influences how the
dataset's window is displayed.  Outside the GUI, the @subcmd{WINDOW} subcommand
has no effect.  The valid values are:

@table @asis
@item ASIS
Do not change how the window is displayed.  This is the default for
DATASET NAME and DATASET ACTIVATE.

@item FRONT
Raise the dataset's window to the top.  Make it the default dataset
for running syntax.

@item MINIMIZED
Display the window ``minimized'' to an icon.  Prefer other datasets
for running syntax.  This is the default for DATASET COPY and DATASET
DECLARE.

@item HIDDEN
Hide the dataset's window.  Prefer other datasets for running syntax.
@end table

@node DATA LIST
@section DATA LIST
@vindex DATA LIST
@cindex reading data from a file
@cindex data, reading from a file
@cindex data, embedding in syntax files
@cindex embedding data in syntax files

Used to read text or binary data, @cmd{DATA LIST} is the most
fundamental data-reading command.  Even the more sophisticated input
methods use @cmd{DATA LIST} commands as a building block.
Understanding @cmd{DATA LIST} is important to understanding how to use
@pspp{} to read your data files.

There are two major variants of @cmd{DATA LIST}, which are fixed
format and free format.  In addition, free format has a minor variant,
list format, which is discussed in terms of its differences from vanilla
free format.

Each form of @cmd{DATA LIST} is described in detail below.

@xref{GET DATA}, for a command that offers a few enhancements over
DATA LIST and that may be substituted for DATA LIST in many
situations.

@menu
* DATA LIST FIXED::             Fixed columnar locations for data.
* DATA LIST FREE::              Any spacing you like.
* DATA LIST LIST::              Each case must be on a single line.
@end menu

@node DATA LIST FIXED
@subsection DATA LIST FIXED
@vindex DATA LIST FIXED
@cindex reading fixed-format data
@cindex fixed-format data, reading
@cindex data, fixed-format, reading
@cindex embedding fixed-format data

@display
DATA LIST [FIXED]
        @{TABLE,NOTABLE@}
        [FILE='@var{file_name}' [ENCODING='@var{encoding}']]
        [RECORDS=@var{record_count}]
        [END=@var{end_var}]
        [SKIP=@var{record_count}]
        /[line_no] @var{var_spec}@dots{}

where each @var{var_spec} takes one of the forms
        @var{var_list} @var{start}-@var{end} [@var{type_spec}]
        @var{var_list} (@var{fortran_spec})
@end display

@cmd{DATA LIST FIXED} is used to read data files that have values at fixed
positions on each line of single-line or multiline records.  The
keyword FIXED is optional.

The @subcmd{FILE} subcommand must be used if input is to be taken from an
external file.  It may be used to specify a file name as a string or a
file handle (@pxref{File Handles}).  If the @subcmd{FILE} subcommand is not used,
then input is assumed to be specified within the command file using
@cmd{BEGIN DATA}@dots{}@cmd{END DATA} (@pxref{BEGIN DATA}).
The @subcmd{ENCODING} subcommand may only be used if the @subcmd{FILE}
subcommand is also used.  It specifies the character encoding of the
file.  @xref{INSERT}, for information on supported encodings.

The optional @subcmd{RECORDS} subcommand, which takes a single integer as an
argument, is used to specify the number of lines per record.
If @subcmd{RECORDS}
is not specified, then the number of lines per record is calculated from
the list of variable specifications later in @cmd{DATA LIST}.

The @subcmd{END} subcommand is only useful in conjunction with @cmd{INPUT
PROGRAM}.  @xref{INPUT PROGRAM}, for details.

The optional @subcmd{SKIP} subcommand specifies a number of records to skip at
the beginning of an input file.  It can be used to skip over a row
that contains variable names, for example.

@cmd{DATA LIST} can optionally output a table describing how the data file
is read.  The @subcmd{TABLE} subcommand enables this output, and
@subcmd{NOTABLE} disables it.  The default is to output the table.

The list of variables to be read from the data list must come last.
Each line in the data record is introduced by a slash (@samp{/}).
Optionally, a line number may follow the slash.  Following, any number
of variable specifications may be present.

Each variable specification consists of a list of variable names
followed by a description of their location on the input line.  Sets of
variables may be specified using the @cmd{DATA LIST} @subcmd{TO} convention
(@pxref{Sets of
Variables}).  There are two ways to specify the location of the variable
on the line: columnar style and FORTRAN style.

In columnar style, the starting column and ending column for the field
are specified after the variable name, separated by a dash (@samp{-}).
For instance, the third through fifth columns on a line would be
specified @samp{3-5}.  By default, variables are considered to be in
@samp{F} format (@pxref{Input and Output Formats}).  (This default can be
changed; see @ref{SET} for more information.)

In columnar style, to use a variable format other than the default,
specify the format type in parentheses after the column numbers.  For
instance, for alphanumeric @samp{A} format, use @samp{(A)}.

In addition, implied decimal places can be specified in parentheses
after the column numbers.  As an example, suppose that a data file has a
field in which the characters @samp{1234} should be interpreted as
having the value 12.34.  Then this field has two implied decimal places,
and the corresponding specification would be @samp{(2)}.  If a field
that has implied decimal places contains a decimal point, then the
implied decimal places are not applied.

Changing the variable format and adding implied decimal places can be
done together; for instance, @samp{(N,5)}.

When using columnar style, the input and output width of each variable is
computed from the field width.  The field width must be evenly divisible
into the number of variables specified.

FORTRAN style is an altogether different approach to specifying field
locations.  With this approach, a list of variable input format
specifications, separated by commas, are placed after the variable names
inside parentheses.  Each format specifier advances as many characters
into the input line as it uses.

Implied decimal places also exist in FORTRAN style.  A format
specification with @var{d} decimal places also has @var{d} implied
decimal places.

In addition to the standard format specifiers (@pxref{Input and Output
Formats}), FORTRAN style defines some extensions:

@table @asis
@item @code{X}
Advance the current column on this line by one character position.

@item @code{T}@var{x}
Set the current column on this line to column @var{x}, with column
numbers considered to begin with 1 at the left margin.

@item @code{NEWREC}@var{x}
Skip forward @var{x} lines in the current record, resetting the active
column to the left margin.

@item Repeat count
Any format specifier may be preceded by a number.  This causes the
action of that format specifier to be repeated the specified number of
times.

@item (@var{spec1}, @dots{}, @var{specN})
Group the given specifiers together.  This is most useful when preceded
by a repeat count.  Groups may be nested arbitrarily.
@end table

FORTRAN and columnar styles may be freely intermixed.  Columnar style
leaves the active column immediately after the ending column
specified.  Record motion using @code{NEWREC} in FORTRAN style also
applies to later FORTRAN and columnar specifiers.

@menu
* DATA LIST FIXED Examples::    Examples of DATA LIST FIXED.
@end menu

@node DATA LIST FIXED Examples
@unnumberedsubsubsec Examples

@enumerate
@item
@c Update the corresponding test in tests/language/commands/data-list.at if you change this.
@example
DATA LIST TABLE /NAME 1-10 (A) INFO1 TO INFO3 12-17 (1).

BEGIN DATA.
John Smith 102311
Bob Arnold 122015
Bill Yates  918 6
END DATA.
@end example

Defines the following variables:

@itemize @bullet
@item
@code{NAME}, a 10-character-wide string variable, in columns 1
through 10.

@item
@code{INFO1}, a numeric variable, in columns 12 through 13.

@item
@code{INFO2}, a numeric variable, in columns 14 through 15.

@item
@code{INFO3}, a numeric variable, in columns 16 through 17.
@end itemize

The @code{BEGIN DATA}/@code{END DATA} commands cause three cases to be
defined:

@example
Case   NAME         INFO1   INFO2   INFO3
   1   John Smith     10      23      11
   2   Bob Arnold     12      20      15
   3   Bill Yates      9      18       6
@end example

The @code{TABLE} keyword causes @pspp{} to print out a table
describing the four variables defined.

@item
@c Update the corresponding test in tests/language/commands/data-list.at if you change this.
@example
DATA LIST FILE="survey.dat"
        /ID 1-5 NAME 7-36 (A) SURNAME 38-67 (A) MINITIAL 69 (A)
        /Q01 TO Q50 7-56
        /.
@end example

Defines the following variables:

@itemize @bullet
@item
@code{ID}, a numeric variable, in columns 1-5 of the first record.

@item
@code{NAME}, a 30-character string variable, in columns 7-36 of the
first record.

@item
@code{SURNAME}, a 30-character string variable, in columns 38-67 of
the first record.

@item
@code{MINITIAL}, a 1-character string variable, in column 69 of
the first record.

@item
Fifty variables @code{Q01}, @code{Q02}, @code{Q03}, @dots{}, @code{Q49},
@code{Q50}, all numeric, @code{Q01} in column 7, @code{Q02} in column 8,
@dots{}, @code{Q49} in column 55, @code{Q50} in column 56, all in the second
record.
@end itemize

Cases are separated by a blank record.

Data is read from file @file{survey.dat} in the current directory.
@end enumerate

@node DATA LIST FREE
@subsection DATA LIST FREE
@vindex DATA LIST FREE

@display
DATA LIST FREE
        [(@{TAB,'@var{c}'@}, @dots{})]
        [@{NOTABLE,TABLE@}]
        [FILE='@var{file_name}' [ENCODING='@var{encoding}']]
        [SKIP=@var{n_records}]
        /@var{var_spec}@dots{}

where each @var{var_spec} takes one of the forms
        @var{var_list} [(@var{type_spec})]
        @var{var_list} *
@end display

In free format, the input data is, by default, structured as a series
of fields separated by spaces, tabs, or line breaks.
If the current @subcmd{DECIMAL} separator is @subcmd{DOT} (@pxref{SET}),
then commas are also treated as field separators.
Each
field's content may be unquoted, or it may be quoted with a pairs of
apostrophes (@samp{'}) or double quotes (@samp{"}).  Unquoted white
space separates fields but is not part of any field.  Any mix of
spaces, tabs, and line breaks is equivalent to a single space for the
purpose of separating fields, but consecutive commas will skip a
field.

Alternatively, delimiters can be specified explicitly, as a
parenthesized, comma-separated list of single-character strings
immediately following FREE.  The word TAB may also be used to specify
a tab character as a delimiter.  When delimiters are specified
explicitly, only the given characters, plus line breaks, separate
fields.  Furthermore, leading spaces at the beginnings of fields are
not trimmed, consecutive delimiters define empty fields, and no form
of quoting is allowed.

The @subcmd{NOTABLE} and @subcmd{TABLE} subcommands are as in @cmd{DATA LIST FIXED} above.
@subcmd{NOTABLE} is the default.

The @subcmd{FILE}, @subcmd{SKIP}, and @subcmd{ENCODING} subcommands
are as in @cmd{DATA LIST FIXED} above.

The variables to be parsed are given as a single list of variable names.
This list must be introduced by a single slash (@samp{/}).  The set of
variable names may contain format specifications in parentheses
(@pxref{Input and Output Formats}).  Format specifications apply to all
variables back to the previous parenthesized format specification.

In addition, an asterisk may be used to indicate that all variables
preceding it are to have input/output format @samp{F8.0}.

Specified field widths are ignored on input, although all normal limits
on field width apply, but they are honored on output.

@node DATA LIST LIST
@subsection DATA LIST LIST
@vindex DATA LIST LIST

@display
DATA LIST LIST
        [(@{TAB,'@var{c}'@}, @dots{})]
        [@{NOTABLE,TABLE@}]
        [FILE='@var{file_name}' [ENCODING='@var{encoding}']]
        [SKIP=@var{record_count}]
        /@var{var_spec}@dots{}

where each @var{var_spec} takes one of the forms
        @var{var_list} [(@var{type_spec})]
        @var{var_list} *
@end display

With one exception, @cmd{DATA LIST LIST} is syntactically and
semantically equivalent to @cmd{DATA LIST FREE}.  The exception is
that each input line is expected to correspond to exactly one input
record.  If more or fewer fields are found on an input line than
expected, an appropriate diagnostic is issued.

@node END CASE
@section END CASE
@vindex END CASE

@display
END CASE.
@end display

@cmd{END CASE} is used only within @cmd{INPUT PROGRAM} to output the
current case.  @xref{INPUT PROGRAM}, for details.

@node END FILE
@section END FILE
@vindex END FILE

@display
END FILE.
@end display

@cmd{END FILE} is used only within @cmd{INPUT PROGRAM} to terminate
the current input program.  @xref{INPUT PROGRAM}.

@node FILE HANDLE
@section FILE HANDLE
@vindex FILE HANDLE

@display
For text files:
        FILE HANDLE @var{handle_name}
                /NAME='@var{file_name}
                [/MODE=CHARACTER]
                [/ENDS=@{CR,CRLF@}]
                /TABWIDTH=@var{tab_width}
                [ENCODING='@var{encoding}']

For binary files in native encoding with fixed-length records:
        FILE HANDLE @var{handle_name}
                /NAME='@var{file_name}'
                /MODE=IMAGE
                [/LRECL=@var{rec_len}]
                [ENCODING='@var{encoding}']

For binary files in native encoding with variable-length records:
        FILE HANDLE @var{handle_name}
                /NAME='@var{file_name}'
                /MODE=BINARY
                [/LRECL=@var{rec_len}]
                [ENCODING='@var{encoding}']

For binary files encoded in EBCDIC:
        FILE HANDLE @var{handle_name}
                /NAME='@var{file_name}'
                /MODE=360
                /RECFORM=@{FIXED,VARIABLE,SPANNED@}
                [/LRECL=@var{rec_len}]
                [ENCODING='@var{encoding}']
@end display

Use @cmd{FILE HANDLE} to associate a file handle name with a file and
its attributes, so that later commands can refer to the file by its
handle name.  Names of text files can be specified directly on
commands that access files, so that @cmd{FILE HANDLE} is only needed when a
file is not an ordinary file containing lines of text.  However,
@cmd{FILE HANDLE} may be used even for text files, and it may be
easier to specify a file's name once and later refer to it by an
abstract handle.

Specify the file handle name as the identifier immediately following the
@cmd{FILE HANDLE} command name.  The identifier INLINE is reserved for
representing data embedded in the syntax file (@pxref{BEGIN DATA}) The
file handle name must not already have been used in a previous
invocation of @cmd{FILE HANDLE}, unless it has been closed by an
intervening command (@pxref{CLOSE FILE HANDLE}).

The effect and syntax of @cmd{FILE HANDLE} depends on the selected MODE:

@itemize
@item
In CHARACTER mode, the default, the data file is read as a text file.
Each text line is read as one record.

In CHARACTER mode only, tabs are expanded to spaces by input programs,
except by @cmd{DATA LIST FREE} with explicitly specified delimiters.
Each tab is 4 characters wide by default, but TABWIDTH (a @pspp{}
extension) may be used to specify an alternate width.  Use a TABWIDTH
of 0 to suppress tab expansion.

A file written in CHARACTER mode by default uses the line ends of the
system on which PSPP is running, that is, on Windows, the default is
CR LF line ends, and on other systems the default is LF only.  Specify
ENDS as CR or CRLF to override the default.  PSPP reads files using
either convention on any kind of system, regardless of ENDS.

@item
In IMAGE mode, the data file is treated as a series of fixed-length
binary records.  LRECL should be used to specify the record length in
bytes, with a default of 1024.  On input, it is an error if an IMAGE
file's length is not an integer multiple of the record length.  On
output, each record is padded with spaces or truncated, if necessary,
to make it exactly the correct length.

@item
In BINARY mode, the data file is treated as a series of
variable-length binary records.  LRECL may be specified, but its value
is ignored.  The data for each record is both preceded and followed by
a 32-bit signed integer in little-endian byte order that specifies the
length of the record.  (This redundancy permits records in these
files to be efficiently read in reverse order, although @pspp{} always
reads them in forward order.)  The length does not include either
integer.

@item
Mode 360 reads and writes files in formats first used for tapes in the
1960s on IBM mainframe operating systems and still supported today by
the modern successors of those operating systems.  For more
information, see @cite{OS/400 Tape and Diskette Device Programming},
available on IBM's website.

Alphanumeric data in mode 360 files are encoded in EBCDIC.  @pspp{}
translates EBCDIC to or from the host's native format as necessary on
input or output, using an ASCII/EBCDIC translation that is one-to-one,
so that a ``round trip'' from ASCII to EBCDIC back to ASCII, or vice
versa, always yields exactly the original data.

The @subcmd{RECFORM} subcommand is required in mode 360.  The precise file
format depends on its setting:

@table @asis
@item F
@itemx FIXED
This record format is equivalent to IMAGE mode, except for EBCDIC
translation.

IBM documentation calls this @code{*F} (fixed-length, deblocked)
format.

@item V
@itemx VARIABLE
The file comprises a sequence of zero or more variable-length blocks.
Each block begins with a 4-byte @dfn{block descriptor word} (BDW).
The first two bytes of the BDW are an unsigned integer in big-endian
byte order that specifies the length of the block, including the BDW
itself.  The other two bytes of the BDW are ignored on input and
written as zeros on output.

Following the BDW, the remainder of each block is a sequence of one or
more variable-length records, each of which in turn begins with a
4-byte @dfn{record descriptor word} (RDW) that has the same format as
the BDW.  Following the RDW, the remainder of each record is the
record data.

The maximum length of a record in VARIABLE mode is 65,527 bytes:
65,535 bytes (the maximum value of a 16-bit unsigned integer), minus 4
bytes for the BDW, minus 4 bytes for the RDW.

In mode VARIABLE, LRECL specifies a maximum, not a fixed, record
length, in bytes.  The default is 8,192.

IBM documentation calls this @code{*VB} (variable-length, blocked,
unspanned) format.

@item VS
@itemx SPANNED
The file format is like that of VARIABLE mode, except that logical
records may be split among multiple physical records (called
@dfn{segments}) or blocks.  In SPANNED mode, the third byte of each
RDW is called the segment control character (SCC).  Odd SCC values
cause the segment to be appended to a record buffer maintained in
memory; even values also append the segment and then flush its
contents to the input procedure.  Canonically, SCC value 0 designates
a record not spanned among multiple segments, and values 1 through 3
designate the first segment, the last segment, or an intermediate
segment, respectively, within a multi-segment record.  The record
buffer is also flushed at end of file regardless of the final record's
SCC.

The maximum length of a logical record in VARIABLE mode is limited
only by memory available to @pspp{}.  Segments are limited to 65,527
bytes, as in VARIABLE mode.

This format is similar to what IBM documentation call @code{*VS}
(variable-length, deblocked, spanned) format.
@end table

In mode 360, fields of type A that extend beyond the end of a record
read from disk are padded with spaces in the host's native character
set, which are then translated from EBCDIC to the native character
set.  Thus, when the host's native character set is based on ASCII,
these fields are effectively padded with character @code{X'80'}.  This
wart is implemented for compatibility.
@end itemize

The @subcmd{NAME} subcommand specifies the name of the file associated with the
handle.  It is required in all modes but SCRATCH mode, in which its
use is forbidden.

The ENCODING subcommand specifies the encoding of text in the file.
For reading text files in CHARACTER mode, all of the forms described
for ENCODING on the INSERT command are supported (@pxref{INSERT}).
For reading in other file-based modes, encoding autodetection is not
supported; if the specified encoding requests autodetection then the
default encoding is used.  This is also true when a file handle
is used for writing a file in any mode.

@node INPUT PROGRAM
@section INPUT PROGRAM
@vindex INPUT PROGRAM

@display
INPUT PROGRAM.
@dots{} input commands @dots{}
END INPUT PROGRAM.
@end display

@cmd{INPUT PROGRAM}@dots{}@cmd{END INPUT PROGRAM} specifies a
complex input program.  By placing data input commands within @cmd{INPUT
PROGRAM}, @pspp{} programs can take advantage of more complex file
structures than available with only @cmd{DATA LIST}.

The first sort of extended input program is to simply put multiple @cmd{DATA
LIST} commands within the @cmd{INPUT PROGRAM}.  This will cause all of
the data
files to be read in parallel.  Input will stop when end of file is
reached on any of the data files.

Transformations, such as conditional and looping constructs, can also be
included within @cmd{INPUT PROGRAM}.  These can be used to combine input
from several data files in more complex ways.  However, input will still
stop when end of file is reached on any of the data files.

To prevent @cmd{INPUT PROGRAM} from terminating at the first end of
file, use
the @subcmd{END} subcommand on @cmd{DATA LIST}.  This subcommand takes a
variable name,
which should be a numeric scratch variable (@pxref{Scratch Variables}).
(It need not be a scratch variable but otherwise the results can be
surprising.)  The value of this variable is set to 0 when reading the
data file, or 1 when end of file is encountered.

Two additional commands are useful in conjunction with @cmd{INPUT PROGRAM}.
@cmd{END CASE} is the first.  Normally each loop through the
@cmd{INPUT PROGRAM}
structure produces one case.  @cmd{END CASE} controls exactly
when cases are output.  When @cmd{END CASE} is used, looping from the end of
@cmd{INPUT PROGRAM} to the beginning does not cause a case to be output.

@cmd{END FILE} is the second.  When the @subcmd{END} subcommand is used on @cmd{DATA
LIST}, there is no way for the @cmd{INPUT PROGRAM} construct to stop
looping,
so an infinite loop results.  @cmd{END FILE}, when executed,
stops the flow of input data and passes out of the @cmd{INPUT PROGRAM}
structure.

@cmd{INPUT PROGRAM} must contain at least one @cmd{DATA LIST} or
@cmd{END FILE} command.

@subheading Example 1: Read two files in parallel to the end of the shorter

The following example reads variable X from file @file{a.txt} and
variable Y from file @file{b.txt}.  If one file is shorter than the
other then the extra data in the longer file is ignored.

@example
INPUT PROGRAM.
    DATA LIST NOTABLE FILE='a.txt'/X 1-10.
    DATA LIST NOTABLE FILE='b.txt'/Y 1-10.
END INPUT PROGRAM.
LIST.
@end example

@subheading Example 2: Read two files in parallel, supplementing the shorter

The following example also reads variable X from @file{a.txt} and
variable Y from @file{b.txt}.  If one file is shorter than the other
then it continues reading the longer to its end, setting the other
variable to system-missing.

@example
INPUT PROGRAM.
    NUMERIC #A #B.

    DO IF NOT #A.
        DATA LIST NOTABLE END=#A FILE='a.txt'/X 1-10.
    END IF.
    DO IF NOT #B.
        DATA LIST NOTABLE END=#B FILE='b.txt'/Y 1-10.
    END IF.
    DO IF #A AND #B.
        END FILE.
    END IF.
    END CASE.
END INPUT PROGRAM.
LIST.
@end example

@subheading Example 3: Concatenate two files (version 1)

The following example reads data from file @file{a.txt}, then from
@file{b.txt}, and concatenates them into a single active dataset.

@example
INPUT PROGRAM.
    NUMERIC #A #B.

    DO IF #A.
        DATA LIST NOTABLE END=#B FILE='b.txt'/X 1-10.
        DO IF #B.
            END FILE.
        ELSE.
            END CASE.
        END IF.
    ELSE.
        DATA LIST NOTABLE END=#A FILE='a.txt'/X 1-10.
        DO IF NOT #A.
            END CASE.
        END IF.
    END IF.
END INPUT PROGRAM.
LIST.
@end example

@subheading Example 4: Concatenate two files (version 2)

This is another way to do the same thing as Example 3.

@example
INPUT PROGRAM.
    NUMERIC #EOF.

    LOOP IF NOT #EOF.
        DATA LIST NOTABLE END=#EOF FILE='a.txt'/X 1-10.
        DO IF NOT #EOF.
            END CASE.
        END IF.
    END LOOP.

    COMPUTE #EOF = 0.
    LOOP IF NOT #EOF.
        DATA LIST NOTABLE END=#EOF FILE='b.txt'/X 1-10.
        DO IF NOT #EOF.
            END CASE.
        END IF.
    END LOOP.

    END FILE.
END INPUT PROGRAM.
LIST.
@end example

@subheading Example 5: Generate random variates

The follows example creates a dataset that consists of 50 random
variates between 0 and 10.

@example
INPUT PROGRAM.
    LOOP #I=1 TO 50.
        COMPUTE X=UNIFORM(10).
        END CASE.
    END LOOP.
    END FILE.
END INPUT PROGRAM.
LIST /FORMAT=NUMBERED.
@end example

@node LIST
@section LIST
@vindex LIST

@display
LIST
        /VARIABLES=@var{var_list}
        /CASES=FROM @var{start_index} TO @var{end_index} BY @var{incr_index}
        /FORMAT=@{UNNUMBERED,NUMBERED@} @{WRAP,SINGLE@}
@end display

The @cmd{LIST} procedure prints the values of specified variables to the
listing file.

The @subcmd{VARIABLES} subcommand specifies the variables whose values are to be
printed.  Keyword VARIABLES is optional.  If @subcmd{VARIABLES} subcommand is not
specified then all variables in the active dataset are printed.

The @subcmd{CASES} subcommand can be used to specify a subset of cases to be
printed.  Specify @subcmd{FROM} and the case number of the first case to print,
@subcmd{TO} and the case number of the last case to print, and @subcmd{BY} and the number
of cases to advance between printing cases, or any subset of those
settings.  If @subcmd{CASES} is not specified then all cases are printed.

The @subcmd{FORMAT} subcommand can be used to change the output format.  @subcmd{NUMBERED}
will print case numbers along with each case; @subcmd{UNNUMBERED}, the default,
causes the case numbers to be omitted.  The @subcmd{WRAP} and @subcmd{SINGLE} settings are
currently not used.

Case numbers start from 1.  They are counted after all transformations
have been considered.

@cmd{LIST} is a procedure.  It causes the data to be read.

@node NEW FILE
@section NEW FILE
@vindex NEW FILE

@display
NEW FILE.
@end display

@cmd{NEW FILE} command clears the dictionary and data from the current
active dataset.

@node PRINT
@section PRINT
@vindex PRINT

@display
PRINT
        [OUTFILE='@var{file_name}']
        [RECORDS=@var{n_lines}]
        [@{NOTABLE,TABLE@}]
        [ENCODING='@var{encoding}']
        [/[@var{line_no}] @var{arg}@dots{}]

@var{arg} takes one of the following forms:
        '@var{string}' [@var{start}]
        @var{var_list} @var{start}-@var{end} [@var{type_spec}]
        @var{var_list} (@var{fortran_spec})
        @var{var_list} *
@end display

The @cmd{PRINT} transformation writes variable data to the listing
file or an output file.  @cmd{PRINT} is executed when a procedure
causes the data to be read.  Follow @cmd{PRINT} by @cmd{EXECUTE} to
print variable data without invoking a procedure (@pxref{EXECUTE}).

All @cmd{PRINT} subcommands are optional.  If no strings or variables
are specified, @cmd{PRINT} outputs a single blank line.

The @subcmd{OUTFILE} subcommand specifies the file to receive the output.  The
file may be a file name as a string or a file handle (@pxref{File
Handles}).  If @subcmd{OUTFILE} is not present then output is sent to
@pspp{}'s output listing file.  When @subcmd{OUTFILE} is present, the
output is written to @var{file_name} in a plain text format, with a
space inserted at beginning of each output line, even lines that
otherwise would be blank.

The @subcmd{ENCODING} subcommand may only be used if the
@subcmd{OUTFILE} subcommand is also used.  It specifies the character
encoding of the file.  @xref{INSERT}, for information on supported
encodings.

The @subcmd{RECORDS} subcommand specifies the number of lines to be output.  The
number of lines may optionally be surrounded by parentheses.

@subcmd{TABLE} will cause the @cmd{PRINT} command to output a table to the listing file
that describes what it will print to the output file.  @subcmd{NOTABLE}, the
default, suppresses this output table.

Introduce the strings and variables to be printed with a slash
(@samp{/}).  Optionally, the slash may be followed by a number
indicating which output line is specified.  In the absence of this
line number, the next line number is specified.  Multiple lines may
be specified using multiple slashes with the intended output for a line
following its respective slash.

Literal strings may be printed.  Specify the string itself.
Optionally the string may be followed by a column number, specifying
the column on the line where the string should start.  Otherwise, the
string is printed at the current position on the line.

Variables to be printed can be specified in the same ways as available
for @cmd{DATA LIST FIXED} (@pxref{DATA LIST FIXED}).  In addition, a
variable
list may be followed by an asterisk (@samp{*}), which indicates that the
variables should be printed in their dictionary print formats, separated
by spaces.  A variable list followed by a slash or the end of command
is interpreted in the same way.

If a FORTRAN type specification is used to move backwards on the current
line, then text is written at that point on the line, the line is
truncated to that length, although additional text being added will
again extend the line to that length.

@node PRINT EJECT
@section PRINT EJECT
@vindex PRINT EJECT

@display
PRINT EJECT
        OUTFILE='@var{file_name}'
        RECORDS=@var{n_lines}
        @{NOTABLE,TABLE@}
        /[@var{line_no}] @var{arg}@dots{}

@var{arg} takes one of the following forms:
        '@var{string}' [@var{start}-@var{end}]
        @var{var_list} @var{start}-@var{end} [@var{type_spec}]
        @var{var_list} (@var{fortran_spec})
        @var{var_list} *
@end display

@cmd{PRINT EJECT} advances to the beginning of a new output page in
the listing file or output file.  It can also output data in the same
way as @cmd{PRINT}.

All @cmd{PRINT EJECT} subcommands are optional.

Without @subcmd{OUTFILE}, @cmd{PRINT EJECT} ejects the current page in
the listing file, then it produces other output, if any is specified.

With @subcmd{OUTFILE}, @cmd{PRINT EJECT} writes its output to the specified file.
The first line of output is written with @samp{1} inserted in the
first column.  Commonly, this is the only line of output.  If
additional lines of output are specified, these additional lines are
written with a space inserted in the first column, as with @subcmd{PRINT}.

@xref{PRINT}, for more information on syntax and usage.

@node PRINT SPACE
@section PRINT SPACE
@vindex PRINT SPACE

@display
PRINT SPACE [OUTFILE='file_name'] [ENCODING='@var{encoding}'] [n_lines].
@end display

@cmd{PRINT SPACE} prints one or more blank lines to an output file.

The @subcmd{OUTFILE} subcommand is optional.  It may be used to direct output to
a file specified by file name as a string or file handle (@pxref{File
Handles}).  If OUTFILE is not specified then output is directed to
the listing file.

The @subcmd{ENCODING} subcommand may only be used if @subcmd{OUTFILE}
is also used.  It specifies the character encoding of the file.
@xref{INSERT}, for information on supported encodings.

n_lines is also optional.  If present, it is an expression
(@pxref{Expressions}) specifying the number of blank lines to be
printed.  The expression must evaluate to a nonnegative value.

@node REREAD
@section REREAD
@vindex REREAD

@display
REREAD [FILE=handle] [COLUMN=column] [ENCODING='@var{encoding}'].
@end display

The @cmd{REREAD} transformation allows the previous input line in a
data file
already processed by @cmd{DATA LIST} or another input command to be re-read
for further processing.

The @subcmd{FILE} subcommand, which is optional, is used to specify the file to
have its line re-read.  The file must be specified as the name of a file
handle (@pxref{File Handles}).  If FILE is not specified then the last
file specified on @cmd{DATA LIST} is assumed (last file specified
lexically, not in terms of flow-of-control).

By default, the line re-read is re-read in its entirety.  With the
@subcmd{COLUMN} subcommand, a prefix of the line can be exempted from
re-reading.  Specify an expression (@pxref{Expressions}) evaluating to
the first column that should be included in the re-read line.  Columns
are numbered from 1 at the left margin.

The @subcmd{ENCODING} subcommand may only be used if the @subcmd{FILE}
subcommand is also used.  It specifies the character encoding of the
file.   @xref{INSERT}, for information on supported encodings.

Issuing @code{REREAD} multiple times will not back up in the data
file.  Instead, it will re-read the same line multiple times.

@node WRITE
@section WRITE
@vindex WRITE

@display
WRITE
        OUTFILE='@var{file_name}'
        RECORDS=@var{n_lines}
        @{NOTABLE,TABLE@}
        /[@var{line_no}] @var{arg}@dots{}

@var{arg} takes one of the following forms:
        '@var{string}' [@var{start}-@var{end}]
        @var{var_list} @var{start}-@var{end} [@var{type_spec}]
        @var{var_list} (@var{fortran_spec})
        @var{var_list} *
@end display

@code{WRITE} writes text or binary data to an output file.

@xref{PRINT}, for more information on syntax and usage.  @cmd{PRINT}
and @cmd{WRITE} differ in only a few ways:

@itemize @bullet
@item
@cmd{WRITE} uses write formats by default, whereas @cmd{PRINT} uses
print formats.

@item
@cmd{PRINT} inserts a space between variables unless a format is
explicitly specified, but @cmd{WRITE} never inserts space between
variables in output.

@item
@cmd{PRINT} inserts a space at the beginning of each line that it
writes to an output file (and @cmd{PRINT EJECT} inserts @samp{1} at
the beginning of each line that should begin a new page), but
@cmd{WRITE} does not.

@item
@cmd{PRINT} outputs the system-missing value according to its
specified output format, whereas @cmd{WRITE} outputs the
system-missing value as a field filled with spaces.  Binary formats
are an exception.
@end itemize
